#!/usr/bin/python3
# script to automate wifi setup via connmanctl
import os
import subprocess
import re

# object to store key network data...
# todo detect type (wifi, managed, etc.)
class NetworkItem(object):
    def __init__(self, status, ssid, serviceKey, id):
        self.status = status
        self.ssid = ssid
        self.serviceKey = serviceKey
        self.id = id

# start fresh
if(os.path.isfile("log")):
    os.remove("log")
if(os.path.isfile("networks")):
    os.remove("networks")

def setupWifi():
    networks = open("networks","wb")
    log = open("log","wb")
    
    print("untethering wifi...")
    command = ["connmanctl","tether","wifi","disable"]
    subprocess.call(command,stdout=log,stderr=log)

    command = ["connmanctl","agent","on"]
    subprocess.call(command,stdout=log,stderr=log)

    networks.close()
    log.close()

def scanNetworks(log_file):
    networks = open("networks","wb")
    log = open("log","wb")
    network_items = []

    print("scanning for available networks...")
    command = ["connmanctl","scan","wifi"]
    subprocess.call(command,stdout=log,stderr=log)

    command = ["connmanctl","services"]
    subprocess.call(command,stdout=networks,stderr=log)

    # must close before reading
    networks.close()
    log.close()
    networks_file = open("networks","r")

    available_networks = networks_file.readlines()

    i = 0
    for network_line in available_networks:
        # splice & clean the list of values
        network_item = network_line.strip().split(" ")
        network_item = list(filter(('').__ne__, network_item))
        
        # this script only cares about wifi items...
        if "wifi" not in network_item[-1]:
            continue
    
        # fill object accordingly
        if (len(network_item) >= 3):
            # detect if connected via first string (i.e. "*AO" means connected)
            status = network_item[0]
            if('O' in status):
                status = 'connected'
            else:
                status = 'available'
            network_items.append(NetworkItem(status,network_item[1],network_item[2],i))
        elif(len(network_item) >= 2):
            network_items.append(NetworkItem("not connected", network_item[0], network_item[1],i))
        else:
            i -= 1
        i += 1
    networks_file.close()
    return network_items

def showNetworks(log_file, network_items):
    print(str(len(network_items)) + " networks are available: ")
    for item in network_items:
        print("(" + str(item.id) + ") " + item.ssid + " - " + item.status)
    print("")

promptNetworks(log_file):
    selection = input("please select a network you wish to connect to: ");
    selected_network = ""
    success = False

    if(selection.isdigit()):
        if(int(selection) < len(network_items) and int(selection) >= 0):
            selected_network = network_items[int(selection)]
            success = True
        else:
            log_file.write("error, network selection out of bounds\n")
    else:
        log_file.write("error, network selection invalid\n")

    if(success == True):
        # selection valid.. configure network here...
        print("valid input!")
    else:
        print("invalid input...")
	return selected_network

def configureNetwork(log_file, selected_network):
	# status ssid serviceKey id
	# this will involve doing the following:
	#config wifi_****_****_managed_psk ipv4 dhcp
	#connect wifi_****_****_managed_psk
	#<enter_passphrase_here>
	#quit
	#ping google.com
	connman_config_file = """# auto-generated by wifi.py... 
		[global]
		Name = <SSID>
		Description = <fill in something descriptive>

		[service_peap]
		Type = wifi
		Name = <SSID - like above>
		EAP = peap
		Phase2 = MSCHAPV2
		Identity = <login>
		Passphrase = <password>"""
	config_file = open("/var/lib/connman/" + selected_network.ssid + ".config"
	


# main...
setupWifi()
log_file = open("log","w")
network_items = scanNetworks(log_file)
showNetworks(log_file, network_items)
chosen_network = promptNetworks(log_file)
if chosenNetwork != "":
	configNetwork(chosenNetwork)

log_file.close()
